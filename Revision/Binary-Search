1. Lower Bound:
Approach: 

    Start with two pointers: low at the start and high at the end of the array. Initialize ans to the size of the array.
    Calculate the middle index, mid, using mid = (low + high) / 2. If arr[mid] is greater than or equal to x, update ans with mid as this could be the the required result and trim down the search space by eliminating the right half, as the smallest possible index is needed for lower bound, so start searching in the left half of the array. Otherwise, search the right half.
    Repeat until the high pointer crosses the low pointer. The ans will hold the index of the lower bound if found, or the size of the array if no such index exists.

    int lowerBound(vector<int>& nums, int x)
    {
        int low = 0, high = nums.size() - 1;
        int ans = nums.size(); 

        while (low <= high) {
            int mid = (low + high) / 2; 

            /* Check if mid element 
               is a potential answer */
            if (nums[mid] >= x) {
                ans = mid; 

                // Search left half
                high = mid - 1; 
            } 
            else {
                // Search right half
                low = mid + 1; 
            }
        }
        return ans; 
    }

2. Upper Bound
Approach: 

    Start with initializing 2 end points which mark the search range of the problem. Lets call them `low` and `high` where `low` pointer starts at the first index, and the `high` pointer points to the last index.
    Along with this there shall be a need for `ans` variable initialized to the size of the array. This variable will store the index of the upper bound, or remain as the size of the array if no upper bound is found.
    Calculate the middle index using simple formula of `mid=(low + high)/2` or `mid=(low+(high-low)/2)`. Compare if the middle index element is greater than the target. In that case update `ans` with `mid` (as that can be a potential answer) and search the left half for a smaller index that meets the condition.
    If middle index element is less than or equal to the target, move to the right half to continue the search. This reduces the search space by half each time.
    Repeat this process until the `low` pointer crosses the `high` pointer. At the end `ans` variable will then hold the index of the upper bound.

       int upperBound(vector<int>& nums, int x)
    {
        int low = 0, high = nums.size() - 1;
        int ans = nums.size();

        // Binary search to find the upper bound
        while (low <= high) {

            // Calculate mid index
            int mid = (low + high) / 2;

            /*  Update ans if current 
                element is greater than x   */
            if (nums[mid] > x) {
                ans = mid;
                high = mid - 1;
            } 
            // Otherwise, move to the right half
            else {
                low = mid + 1;
            }
        }
        return ans;
    }

3. Number of Occurrences:
    result = upperBound_index - lowerBound_Index

4. Find peak element:
Intuition: 

Here, the idea is to use binary search algorithm to optimize the brute-force solution where linear serch was being used. 
For each element (mid), we check if it is greater than its previous and next elements. If so, mid is identified as 
a peak element. Alternatively, if mid is smaller than its previous element, a peak must exist on the left side, so the 
right half is eliminated. Similarly, if mid is less than the next element, a peak must exist on the right side, so the 
left half is eliminated. This approach trims down the search space in each iteration, thereby enhancing the time complexity.

The logic correctly identifies the condition for a mountain peak (arr[mid-1] < arr[mid] > arr[mid+1]) and adjusts 
the search boundaries accordingly.

Approach: 

    Edge cases:
        If n == 1(n is size of the array): If the size of the array is one, then the only element present will the peak element. So, return its index.
        If the current index is 0: While checking for 0th index, it will have only one adjacent element, so just check for the element at 1st index, as -1 index will be invalid index.
        If the current index is (n-1): The last index will also have only one adjacent element as the nth index will be invalid(for 0 based indexing). So just check (n-2)th index.

Initialize two pointers: low to 1 and high to n-2(n is the size of the array), as the 0th and (n-1)th index has already been dealt with in the edge cases. This will describe our search space.

Intialize a while loop which will run till low is less than or equal to high. Now, inside a loop, calculate the value of ‘mid’ using the following formula: mid = (low+high) // 2 ( ‘//’ refers to integer division)
Check if element at [mid] is the peak element, if yes, return the value of 'mid' as the peak element is found at index 'mid'.

If element at [mid] greater than element at [mid-1], this means we are in the left half and eliminate it as the peak element appears on the right.

Otherwise, we are in the right half and eliminate it as the peak element appears on the left. This case also handles the case for the index ‘mid’ being a common point of a decreasing and increasing sequence. It will consider the left peak and eliminate the right peak.

At last if no peak element is found return -1 as an answer.

 int findPeakElement(vector<int> &arr) {
        // Size of array
        int n = arr.size();
        
        // Edge cases:
        if (n == 1) return 0;
        if (arr[0] > arr[1]) return 0;
        if (arr[n - 1] > arr[n - 2]) return n - 1;

        int low = 1, high = n - 2;
        while (low <= high) {
            int mid = (low + high) / 2;

            //If arr[mid] is the peak
            if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1])
                return mid;

            // If we are in the left
            if (arr[mid] > arr[mid - 1]) low = mid + 1;

            /* If we are in the right
            Or, arr[mid] is a common point*/
            else high = mid - 1;
        }
        /* Return -1 if no peak element
        found (dummy return) */
        return -1; 
    }

5. Search in rotated sorted array-I:
Intuition:

The optimal approach would be by dividing the array in halves and implement binary search. The most important thing to note here is that, at any middle point, one side of the array will still be sorted. Use this logic & by figuring out which half is sorted, decide which half to keep searching in, making the search efficient even in a rotated array.

Approach:

    Start with two pointers: low at the beginning and high at the end of the array & calculate the midpoint (mid). If nums[mid] is the target, return mid.
    Determine which half of the array is sorted. If the left half is sorted and the target is within this range, search in the left half. Otherwise, search in the right half, if it is sorted and the target is within this range, search in the right half. Otherwise, search in the left half.
    Continue this process until the pointers low and high cross. If the target is not found, return -1.

class Solution {
public:
    // Function to search for the target element in a rotated sorted array
    int search(vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1; 

        // Applying binary search algorithm 
        while (low <= high) {
            int mid = (low + high) / 2;

            // Check if mid points to the target
            if (nums[mid] == target) return mid;

            // Check if the left part is sorted
            if (nums[low] <= nums[mid]) {
                if (nums[low] <= target && target <= nums[mid]) {
                    // Target exists in the left sorted part
                    high = mid - 1;
                } else {
                    // Target does not exist in the left sorted part
                    low = mid + 1;
                }
            } else {
                // Check if the right part is sorted
                if (nums[mid] <= target && target <= nums[high]) {
                    // Target exists in the right sorted part
                    low = mid + 1;
                } else {
                    // Target does not exist in the right sorted part
                    high = mid - 1;
                }
            }
        }
        // If target is not found
        return -1; 
    }
};

6. Search in rotated sorted array-II:
Intuition

For looking for a target in a rotated sorted array that has duplicates, use binary search for most optimal results. The tricky part is handling duplicates, especially when they are at both ends of the array. Start by finding the sorted half of the array and checking if the target is there. If duplicates make it hard to find the sorted half, just skip them by moving our pointers. This way, keep narrowing down the search space efficiently.

Approach

    Initialize two pointers: low at the start and high at the end of the array.
    Inside a loop, calculate the midpoint (mid). If arr[mid] is the target, return True.
    Check if arr[low], arr[mid], and arr[high] are equal. If so, increment low and decrement high to skip duplicates.
    Identify the sorted half: If arr[low] <= arr[mid], the left half is sorted. Otherwise, the right half is sorted.
    Adjust the pointers based on the target's location: If the left half is sorted and the target is within this range, adjust high to mid - 1. Otherwise, adjust low to mid + 1. If the right half is sorted and the target is within this range, adjust low to mid + 1. Otherwise, adjust high to mid - 1.
    Continue this process until low exceeds high. If no target is found, return False.

class Solution {
public:
    /*  Function to search for the target element 
        in a rotated sorted array with duplicates   */
    bool searchInARotatedSortedArrayII(vector<int>& arr, int target) {
        int n = arr.size();
        int low = 0, high = n - 1;
        
        // Applying binary search algorithm 
        while (low <= high) {
            int mid = (low + high) / 2;

            // Check if mid points to the target
            if (arr[mid] == target) return true;

            // Handle duplicates: if arr[low], arr[mid], and arr[high] are equal
            if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
                low = low + 1;
                high = high - 1;
                continue;
            }

            // Check if the left part is sorted
            if (arr[low] <= arr[mid]) {
                /*  Eliminate the right part if target
                    exists in the left sorted part */
                if (arr[low] <= target && target <= arr[mid]) {
                    high = mid - 1;
                } 
                // Otherwise eliminate the left part
                else {
                    low = mid + 1;
                }
            } else {
                /*  If the right part is sorted and
                    target exists in the right sorted
                    part, eliminate the left part   */
                if (arr[mid] <= target && target <= arr[high]) {
                    low = mid + 1;
                } 
                // Otherwise eliminate the right part
                else {
                    high = mid - 1;
                }
            }
        }
        // If target is not found
        return false;
    }
};

7. Find minimum in Rotated Sorted Array:
Intuition: 

As the given array is sorted and then rotated, we can optimize the brute-force solution by applying the binary search algorithm. In any sorted array, the minimum element is located at the very first index. This observation allows us to reduce the search space by half in each iteration. The task is to identify the sorted half of the array, store its minimum element (which is the first element of this half), and then eliminate this half from our search space.

Approach: 

    First, initialize few variables: low to 0 and high to sizeOfArray - 1, which represent the indices of the array arr that define the current search range, ans to Integer.MAX_VALUE, which ensures that any element in the array will be smaller than ans initially.
    Use a while loop to continue searching while low is less than or equal to high. This ensures that the search space is valid and non-empty. Compute the midpoint mid of the current search range using mid = (low + high) / 2 or mid = low + (high-low)/2.
    Compare element at (low) with element at (mid). If element at (low) is less than or equal to element at (mid), then the left part from low to mid is sorted:
        Update ans with the minimum of its current value and element at (low). This step ensures that ans always holds the smallest element encountered in the sorted part of the array.
        Move the low pointer to mid + 1 to search in the right part of the array, as the minimum element cannot be in the left part (which is already sorted).
    If the left part is not sorted (element at (low) is greater than element at (mid)), then the right part from mid to high is sorted:
        Update ans with the minimum of its current value and element at (mid). This ensures ans contains the smallest element encountered in the sorted part of the array.
        Move the high pointer to mid - 1 to search in the left part of the array, as the minimum element cannot be in the right part (which is already sorted).
    Once the loop completes,` ans` will contain the smallest element found in the rotated sorted array. Return `ans` as the minimum element in the rotated sorted array.

class Solution {
public:
    /* Function to find minimum element
    in a rotated sorted array */
    int findMin(vector<int>& arr) {
        
        // Initialize low and high indices
        int low = 0, high = arr.size() - 1; 
        
        // Initialize ans to maximum integer value
        int ans = INT_MAX;  
        while (low <= high) { 
            int mid = (low + high) / 2; 

            // Check if left part is sorted
            if (arr[low] <= arr[mid]) {
                
                /* Update ans with minimum 
                of ans and arr[low] */
                ans = min(ans, arr[low]);  
                
                // Move to the right part
                low = mid + 1;  
            } 
            else {  
                /* Update ans with minimum 
                of ans and arr[mid] */
                ans = min(ans, arr[mid]);  
                
                // Move to the left part
                high = mid - 1;  
            }
        }
        // Return the minimum element found
        return ans; 
    }
};
